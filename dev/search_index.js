var documenterSearchIndex = {"docs":
[{"location":"userguide/config/#Configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"Empty template configuration.yaml files can be generated with:","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"ElasticFDSG.config_template().","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"The contents of these files must then be fully completed by the user, either manually or with self-written scripts (see examples).","category":"page"},{"location":"userguide/config/#2D","page":"Configurations","title":"2D","text":"","category":"section"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"using ElasticFDSG \n\nElasticFDSG.config_template(CONFIGFILE_PATH; dim=2)\n","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"This saves an empty .yaml file, with hopefully self-explaining configurations:","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"# This is a template configuration.yaml file for a 2D ElasticFDSG simulation.\n# Any other configuration file can be prepared in the same manner.\n# The user must fill them before running a simulation. \n# The velocity model is prepared in another file.\n\nsettings:\n    device: cpu                         # cpu / cuda / metal / intel / amd  \n    precision: Float64                  # Float64 / Float32\n    spatial_derivative_order: 4         # 1-10, but 4 recommended \n    show_progress_in_console: true      # true / false \n    output_file: path/to/my/output/file \ntime:\n    start: 0              \n    end: 1              \n    timestep: 0.005  # (will be checked and changed if unstable)\n\nsource:\n    dominant_frequency:                \n    wavelet_type: ricker               # ricker / gauss1d \n    wavelet_center:                    # (should be ≥ 1.25/fdom) \n    seismic_moment: \n    location:\n        x: 0                                                        \n        z: 0                          \n    moment_tensor:\n        Mxx: 0\n        Mxz: 0\n        Mzz: 0\n        anisotropic: false       # true / false \n\nboundaries: # (absorbing / else)\n    xstart: absorbing      \n    xend:   absorbing         \n    zstart: absorbing        \n    zend:   absorbing\n    pml_layer: 10          \n\nreceivers:\n    geophones:\n        - { x: 0, z: 0 }\n        - { x: 0, z: 0 }\n\n    das:\n        x_aligned:\n            - { x: { start: 0, step: 5, end: 100 }, z: 0 }\n            - { x: { start: 0, step: 5, end: 100 }, z: 0 }\n\n        z_aligned:\n            - { x: 0, z: { start: 0, step: 5, end: 100 } }\n\n    snapshots:\n        # 2D plane snapshots XZ-plane\n        fields: [\"vx\", \"vz\", \"sxx\", \"sxz\", \"szz\"]\n        times: [0, 0.1, 1]\n","category":"page"},{"location":"userguide/config/#3D","page":"Configurations","title":"3D","text":"","category":"section"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"using ElasticFDSG \n\nElasticFDSG.config_template(CONFIGFILE_PATH; dim=3)\n","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"This saves an empty .yaml file, with hopefully self-explaining configurations:","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"# This is a template configuration.yaml file for a 3D ElasticFDSG simulation.\n# Any other configuration file can be prepared in the same manner.\n# The user must fill them before running a simulation. \n# The velocity model is prepared in another file.\n\nsettings:\n    device: cpu                         # cpu / cuda / metal / intel / amd  \n    precision: Float64                  # Float64 / Float32\n    spatial_derivative_order: 4         # 1-10, but 4 recommended \n    show_progress_in_console: true      # true / false \n    output_file: path/to/my/output/file \ntime:\n    start: 0              \n    end: 1              \n    timestep: 0.005  # (will be checked and changed if unstable)\n\nsource:\n    dominant_frequency:                \n    wavelet_type: ricker               # ricker / gauss1d \n    wavelet_center:                    # (should be ≥ 1.25/fdom) \n    seismic_moment: \n    location:\n        x: 0                             \n        y: 0                            \n        z: 0                          \n    moment_tensor:\n        Mxx: 0\n        Mxy: 0\n        Mxz: 0\n        Myy: 0\n        Myz: 0\n        Mzz: 0\n        anisotropic: false       # true / false \n\nboundaries: # (absorbing / else)\n    xstart: absorbing      \n    xend:   absorbing       \n    ystart: absorbing       \n    yend:   absorbing         \n    zstart: absorbing        \n    zend:   absorbing\n    pml_layer: 10          \n\nreceivers:\n    geophones:\n        - { x: 0, y: 0, z: 0 }\n        - { x: 0, y: 0, z: 0 }\n\n    das:\n        x_aligned:\n            - { x: { start: 0, step: 5, end: 100 }, y: 0, z: 0 }\n            - { x: { start: 0, step: 5, end: 100 }, y: 0, z: 0 }\n\n        y_aligned: # empty, if no receiver is required\n\n        z_aligned:\n            - { x: 0, y: 0, z: { start: 0, step: 5, end: 100 } }\n\n    snapshots:\n        # 2D plane snapshots | XY, XZ, YZ - planes centered at plane_positions\n        fields: [\"vx\", \"vy\", \"vz\", \"sxx\", \"sxy\", \"syy\", \"szz\"]\n        times: [0, 0.1, 1]\n        plane_positions:\n            - { x: 100, y: 0, z: 0 }\n            - { x: 0, y:100, z: 0 }\n","category":"page"},{"location":"method/#Theory","page":"Method","title":"Theory","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"This section provides a brief overview of the theoretical basis of the application. For more comprehensive descriptions, readers are referred to literature listed below.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Elastic wave propagation in a 3D anisotropic linear elastic material can be described by the following set of first order partial differential equations:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\npartial_t sigma_xx =  c_11 partial_x v_x + c_12 partial_y v_y + c_13 partial_z v_z   \npartial_t sigma_yy =  c_12 partial_x v_x + c_22 partial_y v_y + c_23 partial_z v_z  \npartial_t sigma_zz =  c_13 partial_x v_x + c_23 partial_y v_y + c_33 partial_z v_z  \npartial_t sigma_xy =  c_66 (partial_x v_y + partial_y v_x)  \npartial_t sigma_xz =  c_55 (partial_x v_z + partial_z v_x)  \npartial_t sigma_yz =  c_44 (partial_y v_z + partial_z v_y) tag1 \n\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nrho partial_t v_x = partial_x sigma_xx + partial_y sigma_xy + partial_z sigma_xz  \nrho partial_t v_y = partial_x sigma_xy + partial_y sigma_yy + partial_z sigma_yz  \nrho partial_t v_z = partial_x sigma_xz + partial_y sigma_xz + partial_z sigma_zz  tag2 \nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"In these equations:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"are sigma_xx sigma_yy sigma_zz the normal stress components.\nare sigma_xy sigma_xz sigma_yz the shear stress components.\nare c_11 c_12 c_13 c_22 c_23 c_33 c_44 c_55 c_66 the 9 elastic constants needed to describe an orthorhombic material.\nis rho is the density of the material.\nare v_x v_y v_z the particle velocities in the x, y, and z directions, respectively.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Using the Tsvankin notation, isotropic, vertical transversal isotropic (VTI) and ortorhombic materials (ORT) can be characterized by two vertical velocities and 7 dimensionless paramters epsilon_1 epsilon_2 gamma_1 gamma_2 delta_1 delta_2 delta_3 :","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nc_33 = v_p0^2 cdot rho \nc_55 = v_s0^2 cdot rho \nc_11 = (2 epsilon_2 + 1) cdot c_33 \nc_22 = c_33 cdot (2 epsilon_1 + 1) \nc_66 = c_55 cdot (2 gamma_1 + 1) \nc_44 = fracc_661 + gamma_2 \nc_13 = sqrt2 c_33 cdot (c_33 - c_55) cdot delta_2 + (c_33 - c_55)^2 - c_55 \nc_23 = sqrt2 c_33 cdot (c_33 - c_44) cdot delta_1 + (c_33 - c_44)^2 - c_44 \nc_12 = sqrt2 c_11 cdot (c_11 - c_66) cdot delta_3 + (c_11 - c_66)^2 - c_66\nendaligned","category":"page"},{"location":"method/#Numerical-Scheme","page":"Method","title":"Numerical Scheme","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"The set of equations (1) and (2) can be solved using a finite-difference staggered-grid scheme. In a staggered grid, field quantities are not co-located on same grid points but are distributed across predefined grid cells. The primary advantage of a staggered grid is an enhanced accuracy of spatial central difference operators, as well as staggered temporal finite difference operators, which also improves the accuracy of the time marching.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"However, the distribution of field quantities within a grid cell also has drawbacks, especially during the processing of the results. For example, users working with geophone data must consider that the velocity components v_x v_y v_z are not measured at the same location.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The staggered grid scheme used in the application is illustrated below:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"      ↑ y                           │      y              △             ■ vₓ  i,j,k\n        │         i+½,j+½           │  z↑ /              /              ◆ vᵧ  i+½,j+½,k\n  i,j+½ │         │vᵧ               │   │/              /               ● v𝑧  i+½,j,k+½ \n   σₓᵧ ─◇─────────◆───              │   ○ ............ ●\n        │         │                 │   ╎              ╎                □ σₓₓ,σᵧᵧ,σ𝑧𝑧 i+½,j,k\n        │         │                 │   ╎              ╎                ○ σₓ𝑧 i,j,k+½\n        │         │                 │   ╎   ◇          ╎  ◆             ◇ σₓᵧ i,j+½,k\n        ■─────────□──── ──→ x       │   ╎  /           ╎ /              △ σᵧ𝑧 i+½,j+½,k+½\n        vₓ      σₓₓ,σᵧᵧ             │   ╎ /            ╎/  \n       i,j       i+½,j              │   ■ ............ □ ─→ x \n                                    │","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Using this scheme, the discrete form of (1) and (2) are given by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\n\nsigma_xx  (i+frac12jk)^t_n+frac12 = sigma_xx  (i+frac12jk)^t_n-frac12 Delta t (c_11 mathcalD_x v_x + c_12 mathcalD_y v_y + c_13 mathcalD_z v_z ) bigg_(i+frac12jk)^t_n  \n\nsigma_yy  (i+frac12jk)^t_n+frac12 = sigma_yy  (i+frac12jk)^t_n-frac12 Delta t (c_12 mathcalD_x v_x + c_22 mathcalD_y v_y + c_23 mathcalD_z v_z ) bigg_(i+frac12jk)^t_n  \n\nsigma_zz  (i+frac12jk)^t_n+frac12 = sigma_zz  (i+frac12jk)^t_n-frac12 Delta t (c_13 mathcalD_x v_x + c_23 mathcalD_y v_y + c_33 mathcalD_z v_z ) bigg_(i+frac12jk)^t_n  \n\nsigma_xy  (ij+frac12k)^t_n+frac12 = sigma_xy  (ij+frac12k)^t_n-frac12 Delta t  c_66 ( mathcalD_x v_y +  mathcalD_y v_x)bigg_(ij+frac12k)^t_n \n\nsigma_xz  (ijk+frac12)^t_n+frac12 = sigma_xz  (ijk+frac12)^t_n-frac12 Delta t  c_55 ( mathcalD_x v_z + mathcalD_z v_x)bigg_(ijk+frac12)^t_n \n\nsigma_yz  (i+frac12j+frac12k+frac12)^t_n+frac12 = sigma_yz  (i+frac12j+frac12k+frac12)^t_n-frac12 Delta t  c_44 ( mathcalD_y v_z +  mathcalD_y v_z)bigg_(i+frac12j+frac12k+frac12)^t_n \n            \n            \nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nv_x  (ijk)^t_n+1 = v_x  (ijk)^t_n fracDelta trho (mathcalD_x sigma_xx + mathcalD_y sigma_xy + mathcalD_z sigma_xz) bigg_(ijk)^t_n+frac12 \nv_y  (i+frac12j+frac12k)^t_n+1 = v_y  (i+frac12j+frac12k)^t_n fracDelta trho (mathcalD_x sigma_xy + mathcalD_y sigma_yy + mathcalD_z sigma_yz) bigg_(i+frac12j+frac12k)^t_n+frac12 \nv_z  (i+frac12jk+frac12)^t_n+1 = v_z  (i+frac12jk+frac12)^t_n fracDelta trho (mathcalD_x sigma_xz + mathcalD_y sigma_xz + mathcalD_z sigma_zz) bigg_(i+frac12jk+frac12)^t_n+frac12 tag3\n\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Here (ijk) represent the grid points in the x,y,z-directions, respectively;  t_n denotes the n-th time step;  and Delta t the time increment.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The differential operators mathcalD are given by central difference approximations:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\n\nmathcalD_x f = sum_n=1^N fracc_nDelta x ( f(x_i+n y_j z_k) - f(x_i- n y_j z_k)) \nmathcalD_y f = sum_n=1^N fracc_nDelta y ( f(x_i y_j+n z_k) - f(x_i y_j-n z_k)) \nmathcalD_z f = sum_n=1^N fracc_nDelta z ( f(x_i y_j z_k+n) - f(x_i y_j z_k-n))\n        \nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"with order N and coefficients c_n.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"To compute a spatial derivative of order N at a specific location, at least N neighboring nodes are required on both sides. As a result, for edge nodes no spatial derivatives can be calculated. These edge nodes (ghost nodes) are effective model boundaries and should lie outside the physical (user-defined) domain. The application automatically extends the user-defined domain with N ghost node layers.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"In staggered grids, it is often beneficial to assign certain elastic properties to specific points within the grid cell. However, requiring users to define such grids can become difficult to manage, particularly for complex media. To simplify this, we define all elastic properties at full integer grid points (e.g., on v_x) and effective properties are calculated by interpolating values from neighboring nodes.","category":"page"},{"location":"method/#Sources","page":"Method","title":"Sources","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Earthquake simulations require the excitation of external double-couple sources. Source terms can be introduced in two different ways:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"As body-force terms acting on the velocity field (e.g., Virieux, 1984). \nAs incremental stresses acting on the stress field (e.g., Shi et al., 2018).","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"In the SG scheme shown above, using incremental stresses requires fewer terms and results in fewer numerical ambiguities compared to body forces, due to the distribution of velocity nodes around a source node.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"A moment tensor source can be described by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nmathbfF(t) = m_0  boldsymbolM  textSTF(t)\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"where m_0 is the seismic moment, textSTF(t) is the source time function, and boldsymbolM is the moment tensor with components:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"M = [ Mxx  Mxy  Mxz\n      Mxy  Myy  Myz\n      Mxz  Myz  Mzz ]","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Assuming a moment-tensor source acting on the stress field, the nearest normal stress node (i+1/2,j,k) serves as the central point. To obtain a symmetrical solution, the shear stress components are then distributed symmetrically around this central node. Thus, in total three normal and twelve shear stress components are required for the full staggered grid formulation:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\n\nV = Delta x Delta y Delta z  \n\ns_xx (i+frac12jk) mathrel-= fracDelta tV M_xx  fracpartial textSTFpartial t \ns_yy (i+frac12jk) mathrel-= fracDelta tV M_yy  fracpartial textSTFpartial t \ns_zz (i+frac12jk) mathrel-= fracDelta tV M_zz  fracpartial textSTFpartial t 05em\n\ns_xy (j+frac12k) mathrel-= fracDelta t4 V M_xy  fracpartial textSTFpartial t \ns_xy (i+1j+frac12k) mathrel-= fracDelta t4 V M_xy  fracpartial textSTFpartial t \ns_xy (ij-frac12k) mathrel-= fracDelta t4 V M_xy  fracpartial textSTFpartial t \ns_xy (i+1j-frac12k) mathrel-= fracDelta t4 V M_xy  fracpartial textSTFpartial t 05em\n\ns_xz (ijk+frac12) mathrel-= fracDelta t4 V M_xz  fracpartial textSTFpartial t \ns_xz (i+1jk+frac12) mathrel-= fracDelta t4 V M_xz  fracpartial textSTFpartial t \ns_xz (ijk-frac12) mathrel-= fracDelta t4 V M_xz  fracpartial textSTFpartial t \ns_xz (ijk-frac12) mathrel-= fracDelta t4 V M_xz  fracpartial textSTFpartial t 05em\n\ns_yz (i+frac12j+frac12k+frac12) mathrel-= fracDelta t4 V M_yz  fracpartial textSTFpartial t \ns_yz (i+frac12j+frac12k-frac12) mathrel-= fracDelta t4 V M_yz  fracpartial textSTFpartial t \ns_yz (i+frac12j-frac12k+frac12) mathrel-= fracDelta t4 V M_yz  fracpartial textSTFpartial t \ns_yz (i+frac12j-frac12k-frac12) mathrel-= fracDelta t4 V M_yz  fracpartial textSTFpartial t\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"where the notation x mathrel-= 1 <-> x = x - 1 is used.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Users who want to model double couple earthquake sources can compute the moment tensor components for the following coordinate system using dip, strike, and rake values:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"     x                  \n   /                     \n  /                        δ = Dip, λ = Rake, Φ = Strike                \n  ---- y                   Coordinate System: x -> north,            \n |                                            y -> east,\n |                                            z -> positive downward\n z","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nM_xx = -(sin(delta)  cos(lambda)  sin(2Phi) + sin(2delta)  sin(lambda)  sin(Phi)^2) \nM_xy = sin(delta)  cos(lambda)  cos(2Phi) + frac12 sin(2delta)  sin(lambda)  sin(2Phi) \nM_xz = -(cos(delta)  cos(lambda)  cos(Phi) + cos(2delta)  sin(lambda)  sin(Phi)) \nM_yy = sin(delta)  cos(lambda)  sin(2Phi) - sin(2delta)  sin(lambda)  cos(Phi)^2 \nM_yz = -(cos(delta)  cos(lambda)  sin(Phi) - cos(2delta)  sin(lambda)  cos(Phi)) \nM_zz = sin(2delta)  sin(lambda)\nendaligned","category":"page"},{"location":"method/#C-PML","page":"Method","title":"C-PML","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Earthquake simulations often require modeling wave propagation in unbounded media. Perfectly Matched Layers (PML) is a very effective method to prevent artificial reflections at model boundaries. The underlying idea is to manipulate the wave equation to obtain exponentially decaying plane wave solutions for complex arguments. Assuming that the computational domain (real arguments) is surrounded by a complex region (the PML region), the amplitudes of incident waves decay and cause negligible reflections at the computational boundaries.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Komatitsch & Martin (2007) introduced a memory efficient convolution-based unsplit PML formulation (C-PML).  This approach requires storing only one additional memory variable for each spatial derivative, but in the PML region only. For the PML region, spatial derivative operators are replaced by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nmathcalD_hatx = fracmathcalD_xkappa_x + Psi_x tag4\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Here, Psi_x represents the memory variable associated with the field from which the derivative is taken. The memory variable Psi_x is updated at each time step by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nPsi_x^t_n = b_x Psi_x^t_n-1 + a_x (mathcalD_x)^t_n + frac12 tag5\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"while a_x, b_x kappa_x are precomputed PML related parameter.  Accordingly, differential operators mathcalD_y and mathcalD_z are replaced by mathcalD_haty and mathcalD_hatz in the PML-region. ","category":"page"},{"location":"method/#Validation","page":"Method","title":"Validation","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"To validate the outputs of the application, numerically derived seismograms are compared with analytical solutions for a homogeneous medium for three different moment tensor sources:  ","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"isotropic (explosive, ISO),  \ndouble couple (DC), and  \ncompensated linear vector dipole (CLVD),","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"given by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"M_textISO =\nbeginbmatrix\n1  0  0 \n0  1  0 \n0  0  1\nendbmatrix\nquad\nM_textDC =\nbeginbmatrix\n0  1  0 \n1  0  0 \n0  0  0\nendbmatrix\nquad\nM_textCLVD =\nbeginbmatrix\n1  0  0 \n0  1  0 \n0  0  -2\nendbmatrix","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Analytical solutions can be obtained by convolving the moment tensors with the Green’s function. For a Cartesian coordinate system that origins at a source location xi_xyz, and a receiver located at x_xyz, we define:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nr_xyz = normxi_xyz - x_xyz \ngamma_xyz = (xi_xyz - x_xyz)r_xyz\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The analytical displacement is then given by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nu_n = M_pq * G_npq 1ex\n    = R_ne  fracM_04 pi rho r^4 \n       int_rv_s^rv_p tau  S(t - tau)  dtau 1ex\n    quad + R_ip^n  frac14 pi rho v_p^2 r^2  S(t - rv_p) 1ex\n    quad + R_is^n  frac14 pi rho v_s^2 r^2  S(t - rv_s) 1ex\n    quad + R_fp^n  frac14 pi rho v_p^3 r  dotS(t - rv_p) 1ex\n    quad + R_fs^n  frac14 pi rho v_s^3 r  dotS(t - rv_s)\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"with the near field term R_ne give by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nR_ne =\nleft( 15 gamma_n gamma_p gamma_q\n     - 3 gamma_n delta_pq\n     - 3 gamma_p delta_nq\n     - 3 gamma_q delta_np right) M_pq\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"the p-wave intermediate field term R_ip give by: ","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nR_ip =\nleft( 6 gamma_n gamma_p gamma_q\n     - gamma_n delta_pq\n     - gamma_p delta_nq\n     - gamma_q delta_np right) M_pq\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"the s-wave intermediate field term R_is give by: ","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nR_is =\n-left( 6 gamma_n gamma_p gamma_q\n      - gamma_n delta_pq\n      - gamma_p delta_nq\n      - 2 gamma_q delta_np right) M_pq\n\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"the p-wave far field term R_fp give by: ","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nR_fpn = left( gamma_n gamma_p gamma_q right) M_pq\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"and the s-wave far field term R_fs give by: ","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nR_fsn = -left( gamma_n gamma_p gamma_q - delta_np gamma_q right) M_pq\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The following figure compares numerically forward-modeled seismograms with analytical solutions for all three moment tensors. Analyitical velocities are obtained by differentiating the displacement.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"(Image: valid)","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"As shown, all errors remain within a reasonable range, confirming the correctness of the moment tensor source implementation and the elastic wave propagation.","category":"page"},{"location":"method/#References","page":"Method","title":"References","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Komatitsch, D., & Martin, R. (2007). An unsplit convolutional perfectly matched layer improved at grazing incidence for the seismic wave equation. Geophysics, 72(5), SM155-SM167.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Moczo, P., Kristek, J., & Gális, M. (2014). The finite-difference modelling of earthquake motions: Waves and ruptures. Cambridge University Press.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Shi, P., Angus, D., Nowacki, A., Yuan, S., & Wang, Y. (2018). Microseismic full waveform modeling in anisotropic media with moment tensor implementation. Surveys in Geophysics, 39(4), 567-611.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Tsvankin, I. (1997). Anisotropic parameters and P-wave velocity for orthorhombic media. Geophysics, 62(4), 1292-1309.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Virieux, J. (1984). SH-wave propagation in heterogeneous media: Velocity-stress finite-difference method. Geophysics, 49(11), 1933-1942. ","category":"page"},{"location":"userguide/velmod/#Velocity-Models","page":"Velocity Models","title":"Velocity Models","text":"","category":"section"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"Velocity models can be prepared in .jld2 (Julia) or .npy/.npz (Python) formats.  This gives users the freedom to design their velocity models in the tool of their choice and adapt them to the required format.  The following explains the required structure for 2D and 3D models and shows how to create simple velocity models in Julia.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"note: Note\nTo simplify the creation of velocity models, all elastic parameters are defined on full-integer grid points in the staggered grid.","category":"page"},{"location":"userguide/velmod/#2D","page":"Velocity Models","title":"2D","text":"","category":"section"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The 2D solver expects an (7, nx, nz) array with:","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"1: X - 2D meshgrid coordinates\n2: Z - 2D meshgrid coordinates \n3: P-wave velocities\n4: S-wave velocities \n5: Densities \n6: 2D Thomsen Parameter epsilon \n7: 2D Thomsen Parameter delta ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"For an isotropic medium, 6 & 7 can be set to zero.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The following script shows how to create a simple 2D velocity model.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"\nusing JLD2\n\n# spatial extends\nh = 10  # step size\nxcoords = 0:10:10000\nzcoords = 0:10:10000\n\n# model dimensions \nnx, nz = length(xcoords), nz = length(zcoords)\ndim = (ny, nx) \n\n# 2D meshgrid coordinates\nX = repeat(xcoords,  1, nz);\nZ = repeat(reshape(zcoords, 1, :), nx, 1)\n\nvp = zeros(dim);   # P-wave velocity\nvs = zeros(dim);   # S-wave velocity\nrho = zeros(dim);  # Density\neps0 = zeros(dim); # 2D Thomson parameter epsilon\ndel0 = zeros(dim); # 2D Thomson parameter delta\n\n# fill arrays with values\nvp[:,:]  .= 5000;  \nvs[:,:]  .= 2500;\nrho[:,:] .= 2800;\n\n# thomson parameter for vti media (zero for isotropic medium)\neps0[:,:] .= 0.2\ndel0[:,:] .= -0.15\n\n# velocity model array\nveldim = (7, ny, nx)\nvelmod = zeros(veldim)\n# fill with elastic properties\nvelmod[1,:,:] .= X\nvelmod[2,:,:] .= Y\nvelmod[3,:,:] .= vp\nvelmod[4,:,:] .= vs\nvelmod[5,:,:] .= rho\nvelmod[6,:,:] .= eps0\nvelmod[7,:,:] .= del0\n\n# save the velocity model\njldsave(VELMODFILE_PATH; velmod)","category":"page"},{"location":"userguide/velmod/#3D","page":"Velocity Models","title":"3D","text":"","category":"section"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The 3D solver expects an (13, nx, ny, nz) array with:","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"1: X - 3D meshgrid coordinates \n2: Y - 3D meshgrid coordinates \n3: Z - 3D meshgrid coordinates \n4: P-wave velocities \n5: S-wave velocities  \n6: Densities  ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"Tsvankin Parameter ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"7: varepsilon_1 \n8: varepsilon_2 \n9: gamma_1 \n10: gamma_2 \n11: delta_1 \n12: delta_2\n13: delta_3 ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"For an isotropic medium, set 7-13 to zero.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"For a VTI medium, the relationship between Tsvankin and Thomsen Parameters can be used:","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"Tsvankin Parameter <=> Thomsen Parameter\nvarepsilon_1 = varepsilon_2 <=> varepsilon\ngamma_1 = gamma_2 <=> gamma\ndelta_1 = delta_2, delta_3 = 0 <=> delta","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The following script shows how to create a simple 3D velocity model.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"\nusing JLD2\n\n# spatial extends\nh = 10\nxcoords = 0:h:1000 # x-coordinates\nycoords = 0:h:1000 # y-coordinates\nzcoords = 0:h:1000 # z-coordinates\n\n# model dimension\nnx, ny, nz = length(xcoords), length(ycoords), length(zcoords)\ndim = (nx, ny, nz) \n\n# 3D meshgrid coordinates\nX = getindex.(Iterators.product(xcoords, ycoords, zcoords), 1)\nY = getindex.(Iterators.product(xcoords, ycoords, zcoords), 2)\nZ = getindex.(Iterators.product(xcoords, ycoords, zcoords), 3)\n\nvp = zeros(dim);    # P-wave velocity\nvs = zeros(dim);    # S-wave velocity\nrho = zeros(dim);   # Density velocity\neps1 = zeros(dim);  # Tsvankin parameter epsilon 1 \neps2 = zeros(dim);  # Tsvankin parameter epsilon 2\ngam1 = zeros(dim);  # Tsvankin parameter gamma 1 \ngam2 = zeros(dim);  # Tsvankin parameter gamma 2 \ndel1 = zeros(dim);  # Tsvankin parameter delta 1 \ndel2 = zeros(dim);  # Tsvankin parameter delta 2 \ndel3 = zeros(dim);  # Tsvankin parameter delta 3 \n\n# fill arrays with values\nvp[:,:,:] .= 5000;\nvs[:,:,:]  .= 2500;\nrho[:,:,:] .= 2800;\n\n# Tsvankin Parameter\neps1[:,:,:]  .= 0.05\neps2[:,:,:]  .= 0.1\ngam1[:,:,:]  .= 0.1\ngam2[:,:,:]  .= -0.05\ndel1[:,:,:]  .= 0.05\ndel2[:,:,:]  .= 0.025\ndel3[:,:,:]  .= -0.1\n\n# velocity model array\nveldim = (13, nx, ny, nz)\nvelmod = zeros(veldim);\n# fill with elastic properties\nvelmod[1,:,:,:] .= X\nvelmod[2,:,:,:] .= Y\nvelmod[3,:,:,:] .= Z\nvelmod[4,:,:,:] .= vp\nvelmod[5,:,:,:] .= vs\nvelmod[6,:,:,:] .= rho\nvelmod[7,:,:,:] .= eps1\nvelmod[8,:,:,:] .= eps2\nvelmod[9,:,:,:] .= gam1\nvelmod[10,:,:,:] .= gam2\nvelmod[11,:,:,:] .= del1\nvelmod[12,:,:,:] .= del2\nvelmod[13,:,:,:] .= del3\n\n# save velocity model in jld2 file\njldsave(VELMODFILE_PATH; velmod)","category":"page"},{"location":"userguide/intro/#General-Usage","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"The core functionalities of the application are:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"ElasticFDSG.dim2.runsim() for 2D simulations \nElasticFDSG.dim3.runsim() for 3D simulations.","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"To run a simulation, the following inputs are required:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"(1) a velocity model stored in a julia (.jld2) or numpy array (.npy/npz)","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"(2) a configuration.yaml file specifying simulation parameters.","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"Once the inputs are ready, a simulation can be initiated like:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"\nusing ElasticFDSG\n\n# set paths\nCONFIGFILE_PATH = \"path/to/my/config_file.yaml\"\nVELMODFILE_PATH = \"path/to/my/velocity_model.jld2\"\n\n# run a 2D simulation\nElasticFDSG.dim2.runsim(path_to_configfile, path_to_velmodfile)\n# run a 3D simulation\nElasticFDSG.dim3.runsim(path_to_configfile, path_to_velmodfile)\n","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"After the calculations are completed, the results will be saved as a .h5 file at the specified location. These results can then be processed using any tool of choice that supports HDF5.  The package provides a function to load the results into a dictionary:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"RESULTFILE_PATH = \"path_to_my_resulth5_file\"\nElasticFDSG.load_results(RESULTFILE_PATH)","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"The following sections demonstrate how to create the required velocity models and configuration files.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#ElasticFDSG.load_results","page":"API Reference","title":"ElasticFDSG.load_results","text":"ElasticFDSG.load_results(filename) Loads a result.h5 file into a dictionary.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ElasticFDSG.print_h5_tree","page":"API Reference","title":"ElasticFDSG.print_h5_tree","text":"ElasticFDSG.printh5tree(filename) Prints tree structure of a result.h5 file.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ElasticFDSG.config_template","page":"API Reference","title":"ElasticFDSG.config_template","text":"ElasticFDSG.config_template(path, dim)\n\nCreates and saves an empty template configuration.yaml file for a ElasticFDSG simulation.  Users can fill the template afterwards. \n\nArguments\n\npath::String: Path where the template is saved.\ndim::Real: dim = 2 => 2D-template, dim=3 => 3D-template\n\n\n\n\n\n","category":"function"},{"location":"reference/#ElasticFDSG.dim2.runsim","page":"API Reference","title":"ElasticFDSG.dim2.runsim","text":"ElasticFDSG.dim2.runsim(CONFIGPATH, VELMODPATH) Run the 2D elastic forward simulation using the specified configuration and velocity model.\n\nArguments:\n\nCONFIGPATH::String: Path to the configuration.yaml file containing simulation settings.\nVELMODPATH::String: Path to the velocity model file. Supported formats: .jld2, .npy, and .npz.\n\nOptional Keyword Arguments:\n\nblock_size::Tuple=(32,32) : Specify numbers of threads launched on GPU. For CPU it will have no effect.\nreturn_::Bool=false: False -> Results will be saved as .h5 file as specified in the config file.                         True  -> Function returns FDSG2D struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ElasticFDSG.dim3.runsim","page":"API Reference","title":"ElasticFDSG.dim3.runsim","text":"ElasticFDSG.dim3.runsim(CONFIGPATH, VELMODPATH) Run the 3D elastic forward simulation using the specified configuration and velocity model.\n\nArguments:\n\nCONFIGPATH::String: Path to the configuration.yaml file containing simulation settings.\nVELMODPATH::String: Path to the velocity model file. Supported formats: .jld2, .npy, and .npz.\n\nOptional Keyword Arguments:\n\nblock_size::Tuple=(7,7,7) : Specify numbers of threads launched on GPU. For CPU it will have no effect.\nreturn_::Bool=false: False -> Results will be saved as .h5 file as specified in the config file.                         True  -> Function returns FDSG3D struct.\n\n\n\n\n\n","category":"function"},{"location":"#ElasticFDSG.jl","page":"Home","title":"ElasticFDSG.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ElasticFDSG.jl is a Julia package for solving the elastic wave equation in the velocity–stress formulation using the finite-difference method on a staggered grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"But why another implementation? In many existing tools, installing dependencies, configuring simulation setups, defining model parameters, and accessing results can be already complicated tasks — particularly for inexperienced users who are looking for a quick and straightforward workflow. ElasticFDSG was developed to offer a user-friendly experience while also maintaining flexibility to be applied to a wide variety of simulation scenarios. Users can easily customize their simulations by creating velocity models and configuration files in a straightforward manner, that can be directly passed to the solvers.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"2D and 3D elastic forward modelling on regular grids.\nVendor neutral CPU and GPU kernel (CPU, CUDA, Metal, AMDGPU, oneAPI) using KernelAbstractions.jl.\nSpatial derivatives of order 1 to 10.\nSecond order time marching.\nElastic isotropic or vertical transversal isotrop (VTI) 2D models using 2D Thomson parameter.\nElastic isotropic, VTI or orthorhombic (ORT) 3D models using Tsvankin parameter.\nElastic properties defined on full integer grid points.\nSolver can handle fully heterogeneous media.\nAbsorbing boundaries using Convolutional-Perfectly-Matched-Layer.\nMoment tensor sources. \nSave geophone receiver (velocity point sensors). \nSave Distributed Acoustic Sensing (DAS) receiver, aligned with model coordinate axis (strain-profiles).\nSave snapshots at specified time steps.\nEasy-to-read source code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A step by step user guide can be found in the User Guide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic examples are included in the git-repository examples/ folder. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Demo)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(ElasticFDSG)","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this package helpful for your research, please consider citing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ElasticFDSG,\n  author       = {William Tegtow},\n  title        = {ElasticFDSG.jl: Simulating elastic wave propagation in 2D and 3D anisotropic media.},\n  year         = {2025},\n  doi          = {https://doi.org/10.5281/zenodo.14872584}\n}\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in its early stages, and only limited testing has been done so far. Any bug report or suggestion is very welcomed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nOld scripts may need to be revised to be compatible with the latest version.With v1.0.2, the structure of the configuration.yaml files has slightly changed. \nWith v1.0.2, 2D velocity models must now be saved as (Nx,Nz) arrays instead from previously (Nz,Nx). ","category":"page"}]
}
