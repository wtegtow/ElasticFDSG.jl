var documenterSearchIndex = {"docs":
[{"location":"userguide/config/#Configurations","page":"Configurations","title":"Configurations","text":"","category":"section"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"Empty template configuration.yaml files can be generated with:","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"ElasticFDSG.config_template().","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"The contents of these files must then be fully completed by the user either manually or with self-written scripts (see examples)","category":"page"},{"location":"userguide/config/#2D","page":"Configurations","title":"2D","text":"","category":"section"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"using ElasticFDSG \n\nconfiguration_file_path = \"path/to/my/config_file.yaml\" \nElasticFDSG.config_template(configuration_file_path; dim=2)\n","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"This saves the .yaml file with hopefully self-explaining settings:","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"# This is a template configuration.yaml file for a 2D ElasticFDSG simulation.\n# Any other configuration file can be prepared in the same manner.\n# The user must fill them before running a simulation. \n# The velocity model is prepared in another file.\n\nsettings:\n    device: cpu                         # cpu / cuda / metal / intel / amd  \n    precision: Float64                  # Float64 / Float32\n    spatial_derivative_order: 4         # 1-10, but 4 recommended \n    show_progress_in_console: true      # true / false \n    output_file: path/to/my/output/file \ntime:\n    start: 0              \n    end: 1              \n    timestep: 0.005  # (will be checked and changed if unstable)\n\nsource:\n    dominant_frequency:                \n    wavelet_type: ricker               # ricker / gauss1d \n    wavelet_center:                    # (should be â‰¥ 1.25/fdom) \n    seismic_moment: \n    location:\n        x: 0                                                        \n        z: 0                          \n    moment_tensor:\n        Mxx: 0\n        Mxz: 0\n        Mzz: 0\n        anisotropic: false       # true / false \n\nboundaries: # (absorbing / else)\n    xstart: absorbing      \n    xend:   absorbing         \n    zstart: absorbing        \n    zend:   absorbing\n    pml_layer: 10          \n\nreceivers:\n    geophones:\n        - { x: 0, z: 0 }\n        - { x: 0, z: 0 }\n\n    das:\n        x_aligned:\n            - { x: { start: 0, step: 5, end: 100 }, z: 0 }\n            - { x: { start: 0, step: 5, end: 100 }, z: 0 }\n\n        z_aligned:\n            - { x: 0, z: { start: 0, step: 5, end: 100 } }\n\n    snapshots:\n        # 2D plane snapshots XZ-plane\n        fields: [\"vx\", \"vz\", \"sxx\", \"sxz\", \"szz\"]\n        times: [0, 0.1, 1]\n","category":"page"},{"location":"userguide/config/#3D","page":"Configurations","title":"3D","text":"","category":"section"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"using ElasticFDSG \n\nconfiguration_file_path = \"path/to/my/config_file.yaml\"  # add your actual path here \nElasticFDSG.config_template(configuration_file_path; dim=3)\n","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"This saves the .yaml file with hopefully self-explaining settings:","category":"page"},{"location":"userguide/config/","page":"Configurations","title":"Configurations","text":"# This is a template configuration.yaml file for a 3D ElasticFDSG simulation.\n# Any other configuration file can be prepared in the same manner.\n# The user must fill them before running a simulation. \n# The velocity model is prepared in another file.\n\nsettings:\n    device: cpu                         # cpu / cuda / metal / intel / amd  \n    precision: Float64                  # Float64 / Float32\n    spatial_derivative_order: 4         # 1-10, but 4 recommended \n    show_progress_in_console: true      # true / false \n    output_file: path/to/my/output/file \ntime:\n    start: 0              \n    end: 1              \n    timestep: 0.005  # (will be checked and changed if unstable)\n\nsource:\n    dominant_frequency:                \n    wavelet_type: ricker               # ricker / gauss1d \n    wavelet_center:                    # (should be â‰¥ 1.25/fdom) \n    seismic_moment: \n    location:\n        x: 0                             \n        y: 0                            \n        z: 0                          \n    moment_tensor:\n        Mxx: 0\n        Mxy: 0\n        Mxz: 0\n        Myy: 0\n        Myz: 0\n        Mzz: 0\n        anisotropic: false       # true / false \n\nboundaries: # (absorbing / else)\n    xstart: absorbing      \n    xend:   absorbing       \n    ystart: absorbing       \n    yend:   absorbing         \n    zstart: absorbing        \n    zend:   absorbing\n    pml_layer: 10          \n\nreceivers:\n    geophones:\n        - { x: 0, y: 0, z: 0 }\n        - { x: 0, y: 0, z: 0 }\n\n    das:\n        x_aligned:\n            - { x: { start: 0, step: 5, end: 100 }, y: 0, z: 0 }\n            - { x: { start: 0, step: 5, end: 100 }, y: 0, z: 0 }\n\n        y_aligned: # empty, if no receiver is required\n\n        z_aligned:\n            - { x: 0, y: 0, z: { start: 0, step: 5, end: 100 } }\n\n    snapshots:\n        # 2D plane snapshots | XY, XZ, YZ - planes centered at plane_positions\n        fields: [\"vx\", \"vy\", \"vz\", \"sxx\", \"sxy\", \"syy\", \"szz\"]\n        times: [0, 0.1, 1]\n        plane_positions:\n            - { x: 100, y: 0, z: 0 }\n            - { x: 0, y:100, z: 0 }\n","category":"page"},{"location":"method/#Theory","page":"Method","title":"Theory","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"This section provides a brief overview of the theoretical basis of the application. For more comprehensive descriptions, readers are referred to literature listed below.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Elastic wave propagation in a 3D anisotropic linear elastic material can be described by the following set of first order partial differential equations:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\npartial_t sigma_xx =  c_11 partial_x v_x + c_12 partial_y v_y + c_13 partial_z v_z   \npartial_t sigma_yy =  c_12 partial_x v_x + c_22 partial_y v_y + c_23 partial_z v_z  \npartial_t sigma_zz =  c_13 partial_x v_x + c_23 partial_y v_y + c_33 partial_z v_z  \npartial_t sigma_xy =  c_66 (partial_x v_y + partial_y v_x)  \npartial_t sigma_xz =  c_55 (partial_x v_z + partial_z v_x)  \npartial_t sigma_yz =  c_44 (partial_y v_z + partial_z v_y) tag1 \n\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nrho partial_t v_x = partial_x sigma_xx + partial_y sigma_xy + partial_z sigma_xz + f_x \nrho partial_t v_y = partial_x sigma_xy + partial_y sigma_yy + partial_z sigma_yz + f_y \nrho partial_t v_z = partial_x sigma_xz + partial_y sigma_xz + partial_z sigma_zz + f_z tag2 \nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"In these equations:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"are sigma_xx sigma_yy sigma_zz the normal stress components.\nare sigma_xy sigma_xz sigma_yz the shear stress components.\nare c_11 c_12 c_13 c_22 c_23 c_33 c_44 c_55 c_66 the 9 elastic constants needed to describe an orthorhombic material.\nis rho is the density of the material.\nare v_x v_y v_z the particle velocities in the x, y, and z directions, respectively.\nare f_x f_y f_z the external body forces acting in the x, y, and z directions, respectively.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Using the Tsvankin notation, isotropic, vertical transversal isotropic (VTI) and ortorhombic materials (ORT) can be characterized by two vertical velocities and 7 dimensionless paramters epsilon_1 epsilon_2 gamma_1 gamma_2 delta_1 delta_2 delta_3 :","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nc_33 = v_p0^2 cdot rho \nc_55 = v_s0^2 cdot rho \nc_11 = (2 epsilon_2 + 1) cdot c_33 \nc_22 = c_33 cdot (2 epsilon_1 + 1) \nc_66 = c_55 cdot (2 gamma_1 + 1) \nc_44 = fracc_661 + gamma_2 \nc_13 = sqrt2 c_33 cdot (c_33 - c_55) cdot delta_2 + (c_33 - c_55)^2 - c_55 \nc_23 = sqrt2 c_33 cdot (c_33 - c_44) cdot delta_1 + (c_33 - c_44)^2 - c_44 \nc_12 = sqrt2 c_11 cdot (c_11 - c_66) cdot delta_3 + (c_11 - c_66)^2 - c_66\nendaligned","category":"page"},{"location":"method/#Numerical-Scheme","page":"Method","title":"Numerical Scheme","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"The set of equations (1) and (2) can be solved using a finite-difference staggered-grid scheme. In a staggered grid, field quantities are not co-located on same grid points but are distributed across predefined grid cells. The primary advantage of a staggered grid is an enhanced accuracy of spatial central difference operators, as well as staggered temporal finite difference operators, which also improves the accuracy of the time marching.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"However, the distribution of field quantities within a grid cell also has drawbacks, especially during the processing of the results. For example, users working with geophone data must consider that the velocity components v_x v_y v_z are not measured at the same location.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The staggered grid scheme used in the application is illustrated below:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"      â†‘ y                           â”‚      y              â–³             â–  vâ‚“  i,j,k\n        â”‚         i+Â½,j+Â½           â”‚  zâ†‘ /              /              â—† váµ§  i+Â½,j+Â½,k\n  i,j+Â½ â”‚         â”‚váµ§               â”‚   â”‚/              /               â— vð‘§  i+Â½,j,k+Â½ \n   Ïƒâ‚“áµ§ â”€â—‡â”€â”€â”€â”€â”€â”€â”€â”€â”€â—†â”€â”€â”€              â”‚   â—‹ ............ â—\n        â”‚         â”‚                 â”‚   â•Ž              â•Ž                â–¡ Ïƒâ‚“â‚“,Ïƒáµ§áµ§,Ïƒð‘§ð‘§ i+Â½,j,k\n        â”‚         â”‚                 â”‚   â•Ž              â•Ž                â—‹ Ïƒâ‚“ð‘§ i,j,k+Â½\n        â”‚         â”‚                 â”‚   â•Ž   â—‡          â•Ž  â—†             â—‡ Ïƒâ‚“áµ§ i,j+Â½,k\n        â– â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¡â”€â”€â”€â”€ â”€â”€â†’ x       â”‚   â•Ž  /           â•Ž /              â–³ Ïƒáµ§ð‘§ i+Â½,j+Â½,k+Â½\n        vâ‚“      Ïƒâ‚“â‚“,Ïƒáµ§áµ§             â”‚   â•Ž /            â•Ž/  \n       i,j       i+Â½,j              â”‚   â–  ............ â–¡ â”€â†’ x \n                                    â”‚","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Using this scheme, the discrete form of (1) and (2) are given by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\n\nsigma_xx  (i+frac12jk)^t_n+frac12 = sigma_xx  (i+frac12jk)^t_n-frac12 Delta t (c_11 mathcalD_x v_x + c_12 mathcalD_y v_y + c_13 mathcalD_z v_z ) bigg_(i+frac12jk)^t_n  \n\nsigma_yy  (i+frac12jk)^t_n+frac12 = sigma_yy  (i+frac12jk)^t_n-frac12 Delta t (c_12 mathcalD_x v_x + c_22 mathcalD_y v_y + c_23 mathcalD_z v_z ) bigg_(i+frac12jk)^t_n  \n\nsigma_zz  (i+frac12jk)^t_n+frac12 = sigma_zz  (i+frac12jk)^t_n-frac12 Delta t (c_13 mathcalD_x v_x + c_23 mathcalD_y v_y + c_33 mathcalD_z v_z ) bigg_(i+frac12jk)^t_n  \n\nsigma_xy  (ij+frac12k)^t_n+frac12 = sigma_xy  (ij+frac12k)^t_n-frac12 Delta t  c_66 ( mathcalD_x v_y +  mathcalD_y v_x)bigg_(ij+frac12k)^t_n \n\nsigma_xz  (ijk+frac12)^t_n+frac12 = sigma_xz  (ijk+frac12)^t_n-frac12 Delta t  c_55 ( mathcalD_x v_z + mathcalD_z v_x)bigg_(ijk+frac12)^t_n \n\nsigma_yz  (i+frac12j+frac12k+frac12)^t_n+frac12 = sigma_yz  (i+frac12j+frac12k+frac12)^t_n-frac12 Delta t  c_44 ( mathcalD_y v_z +  mathcalD_y v_z)bigg_(i+frac12j+frac12k+frac12)^t_n \n            \n            \nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nv_x  (ijk)^t_n+1 = v_x  (ijk)^t_n fracDelta trho (mathcalD_x sigma_xx + mathcalD_y sigma_xy + mathcalD_z sigma_xz + f_x) bigg_(ijk)^t_n+frac12 \nv_y  (i+frac12j+frac12k)^t_n+1 = v_y  (i+frac12j+frac12k)^t_n fracDelta trho (mathcalD_x sigma_xy + mathcalD_y sigma_yy + mathcalD_z sigma_yz + f_y) bigg_(i+frac12j+frac12k)^t_n+frac12 \nv_z  (i+frac12jk+frac12)^t_n+1 = v_z  (i+frac12jk+frac12)^t_n fracDelta trho (mathcalD_x sigma_xz + mathcalD_y sigma_xz + mathcalD_z sigma_zz + f_z) bigg_(i+frac12jk+frac12)^t_n+frac12 tag3\n\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Here (ijk) represent the grid points in the x,y,z-directions, respectively;  t_n denotes the n-th time step;  and Delta t the time increment.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The differential operators mathcalD are given by central difference approximations:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\n\nmathcalD_x f = sum_n=1^N fracc_nDelta x ( f(x_i+n y_j z_k) - f(x_i- n y_j z_k)) \nmathcalD_y f = sum_n=1^N fracc_nDelta y ( f(x_i y_j+n z_k) - f(x_i y_j-n z_k)) \nmathcalD_z f = sum_n=1^N fracc_nDelta z ( f(x_i y_j z_k+n) - f(x_i y_j z_k-n))\n        \nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"with order N and coefficients c_n.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"To compute a spatial derivative of order N at a specific location, at least N neighboring nodes are required on both sides. As a result, for edge nodes no spatial derivatives can be calculated. These edge nodes (ghost nodes) are effective model boundaries and should lie outside the physical (user-defined) domain. The application automatically extends the user-defined domain with N ghost node layers.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"In staggered grids, it is often beneficial to assign certain elastic properties to specific points within the grid cell. However, requiring users to define such grids can become difficult to manage, particularly for complex media. To simplify this, we define all elastic properties at full integer grid points (e.g., on v_x) and effective properties are calculated by interpolating values from neighboring nodes.","category":"page"},{"location":"method/#Sources","page":"Method","title":"Sources","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Earthquake simulations require the excitation of point or double-couple forces using the body force term in the equation of motion.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Point Sources:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Point sources can directly be applied to the velocity components at the desired source location (s_xs_ys_y), using elevation and azimuth angles combined with a source-time function that contains a wavelet. However, due to the positions of velocity components in the grid cell, the excitation occurs at slightly different locations.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Double couple sources","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Double-couple sources involve applying force pairs (pq) with strength M_pq to the velocity field at a desired source location. In the used staggered grid scheme, double-couple sources are centered around normal stresses grid points, i.e., (i+frac12jk). As a result, a defined double couple source location is centered shifted by half a grid point in the x-direction!  Using moment tensors to represent the equivalent distribution of force pairs, at least 30 force contributions need to be applied to the surounding velocity field. The 10 force components contributing to f_x are:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nf_x  ijk = - f_x  i+1jk = fracM_xx(t)Delta x^2 Delta y Delta z \n\nf_x  ij+1k = - f_x  ij-1k = fracM_xy(t)4 Delta x Delta y^2 Delta z \nf_x  i+1j+1k = - f_x  i+1j-1k = fracM_xy(t)4 Delta x  Delta y^2  Delta z \n\nf_x  ijk+1 = - f_x  ijk-1 = fracM_xz(t)4 Delta x Delta y Delta z^2 \nf_x  i+1jk+1 = - f_x i+1jk-1 = fracM_xz(t)4 Delta x Delta y Delta z^2 \n\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The same logic applies to the body force components contributing to f_y and f_z.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"The moment tensor components are computed by user defined dip, strike and rake values for the following coordinate system:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"     x                  \n   /                     \n  /                        Î´ = Dip, Î» = Rake, Î¦ = Strike                \n  ---- y                   Coordinate System: x -> north,            \n |                                            y -> east,\n |                                            z -> positive downward\n z","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nM_xx = -(sin(delta)  cos(lambda)  sin(2Phi) + sin(2delta)  sin(lambda)  sin(Phi)^2) \nM_xy = sin(delta)  cos(lambda)  cos(2Phi) + frac12 sin(2delta)  sin(lambda)  sin(2Phi) \nM_xz = -(cos(delta)  cos(lambda)  cos(Phi) + cos(2delta)  sin(lambda)  sin(Phi)) \nM_yy = sin(delta)  cos(lambda)  sin(2Phi) - sin(2delta)  sin(lambda)  cos(Phi)^2 \nM_yz = -(cos(delta)  cos(lambda)  sin(Phi) - cos(2delta)  sin(lambda)  cos(Phi)) \nM_zz = sin(2delta)  sin(lambda)\nendaligned","category":"page"},{"location":"method/#C-PML","page":"Method","title":"C-PML","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Earthquake simulations often require modeling wave propagation in unbounded media. Perfectly Matched Layer (PML) is a very effective method to prevent artificial reflections at model boundaries. The underlying idea is to manipulate the wave equation to obtain exponentially decaying plane wave solutions for complex arguments. Assuming that the computational domain (real arguments) is surrounded by a complex region (the PML region), the amplitudes of incident waves decay and cause negligible reflections at the model boundaries.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Komatitsch & Martin (2007) introduced a memory efficient convolution-based unsplit PML formulation (C-PML).  This approach requires storing one additional memory variable for each spatial derivative, but only in the PML region. For the PML region, spatial derivative operators are replaced by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nmathcalD_hatx = fracmathcalD_xkappa_x + Psi_x tag4\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Here, Psi_x represents the memory variable associated with the field from which the derivative is taken. The memory variable Psi_x is updated at each time step by:","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"beginaligned\nPsi_x^t_n = b_x Psi_x^t_n-1 + a_x (mathcalD_x)^t_n + frac12 tag5\nendaligned","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"while a_x, b_x kappa_x are precomputed PML related parameter. ","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Accordingly, differential operators mathcalD_y and mathcalD_z are replaced by mathcalD_haty and mathcalD_hatz in the PML-region.","category":"page"},{"location":"method/#References","page":"Method","title":"References","text":"","category":"section"},{"location":"method/","page":"Method","title":"Method","text":"Komatitsch, D., & Martin, R. (2007). An unsplit convolutional perfectly matched layer improved at grazing incidence for the seismic wave equation. Geophysics, 72(5), SM155-SM167.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Moczo, P., Kristek, J., & GÃ¡lis, M. (2014). The finite-difference modelling of earthquake motions: Waves and ruptures. Cambridge University Press.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Tsvankin, I. (1997). Anisotropic parameters and P-wave velocity for orthorhombic media. Geophysics, 62(4), 1292-1309.","category":"page"},{"location":"method/","page":"Method","title":"Method","text":"Virieux, J. (1984). SH-wave propagation in heterogeneous media: Velocity-stress finite-difference method. Geophysics, 49(11), 1933-1942. ","category":"page"},{"location":"validate/#Validation","page":"Validation","title":"Validation","text":"","category":"section"},{"location":"validate/","page":"Validation","title":"Validation","text":"To validate the outputs of the application, numerically derived seismometers are compared with analytical solutions for a given homogeneous medium.","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"Solutions for inhomogeneous partial differential equations can be obtained using Green's functions  G(mathbfx t mathbfx_0 t_0) with delta-functions as source terms acting on (mathbfx t) and activated on (mathbfx_0 t_0).","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"The solution to that problem leads to the practical relationship that the displacement field can be described by a convolution of the Green's function with the source-time function:","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"\nu_i = G * S quad i in x y z\n","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"The velocity can then be derived as:","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"\nv_i = fracpartial u_ipartial t quad i in x y z\n","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"In the 2D case, the Green's function is given by:","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"G_2D(mathbfx t mathbfx_0 t_0) = frac12pi rho c^2 fracHbiggl((t-t_0)-fracrcbiggr)sqrt(t-t_0)^2-fracr^2c^2\n","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"and in the 3D case:","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"\nG_3D(mathbfx t mathbfx_0 t_0) = frac14 pi rho c^2 r delta(t - fracrc)\n\n","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"In the equations above, rho represents the density, c is the wave speed, H is the Heaviside function, delta is the Dirac delta function and r the 2 and 3D Euclidian distance, respectivly.","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"The following images show a comparison of numerical seismograms with corresponding analytical solutions (red dashed lines). ","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"2D: (Image: comp)","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"3D:  (Image: comp)","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"The examples above were selected to illustrate grid-dispersion. As indicated, grid-dispersion can be counteracted with higher order spatial derivative operators N.  However, more important is to set the grid spacing sufficiently fine to avoid grid-dispersion. The images show that the numerical solution is sufficiently close to the analytical one, but the quality of the solution depends on the simulation setup.","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"For heterogeneous media, analytical solutions are not so easily obtainable.  Additionally, unique characteristics of various numerical methods make it challenging to compare results across different approaches. For that reason, the \"validation\" of heterogeneous media is yet left completely on a visible basis:","category":"page"},{"location":"validate/","page":"Validation","title":"Validation","text":"(Image: 2danim)","category":"page"},{"location":"userguide/intro/#General-Usage","page":"General Usage","title":"General Usage","text":"","category":"section"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"The core functionalities of the application are:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"ElasticFDSG.dim2.runsim() for 2D simulations \nElasticFDSG.dim3.runsim() for 3D simulations.","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"To run a simulation, the following inputs are required:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"(1) a velocity model stored in a julia (.jld2) or numpy array (.npy/npz)","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"(2) a configuration.yaml file specifying simulation parameters.","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"Once the inputs are ready, a simulation can be initiated like:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"\nusing ElasticFDSG\n\n# paths\npath_to_configfile = \"path/to/my/config_file.yaml\"\npath_to_velmodfile = \"path/to/my/velocity_model.jld2\"\n\n# run a 2D simulation\nElasticFDSG.dim2.runsim(path_to_configfile, path_to_velmodfile)\n\n# run a 3D simulation\nElasticFDSG.dim3.runsim(path_to_configfile, path_to_velmodfile)\n","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"After the calculations are completed, the results will be saved as a .h5 file at the specified location. These results can then be processed using any tool of choice that supports HDF5. Below is an example of how to access the content of the results file with Julia:","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"using HDF5\n\n# extract content from result file \nfunction extract_hdf5_content(file_path::String)\n    file = h5open(file_path, \"r\")\n    result = Dict()\n    \n    function process_group(group, prefix=\"\")\n        for name in keys(group)\n            path = joinpath(prefix, name)\n            obj = group[name]\n            if obj isa HDF5.Group\n                process_group(obj, path)\n            elseif obj isa HDF5.Dataset\n                result[path] = read(obj)\n            else\n                ;\n            end\n        end\n    end\n    \n    process_group(file)\n    close(file)\n    return result\nend;\n\nfile_path = joinpath(@__DIR__, \"results.h5\"); # add the actual path here\ncontent = extract_hdf5_content(file_path);\n\nprintln(\"Content keys\")\nfor (key, value) in content\n    println(\"$key\")\nend","category":"page"},{"location":"userguide/intro/","page":"General Usage","title":"General Usage","text":"In the next sections, the process for creating required velocity models and configuration files will be demonstrated.","category":"page"},{"location":"userguide/velmod/#Velocity-Models","page":"Velocity Models","title":"Velocity Models","text":"","category":"section"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"Velocity models can be prepared in .jld2 (Julia) or .npy/.npz (Python) formats.  This gives users the freedom to design their velocity models in the tool of their choice and adapt them to the required format.  The following explains the required structure for 2D and 3D models and shows how to create simple velocity models in Julia.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"note: Note\nTo simplify the creation of velocity models, all elastic parameters are defined on full-integer grid points in the staggered grid.","category":"page"},{"location":"userguide/velmod/#2D","page":"Velocity Models","title":"2D","text":"","category":"section"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The 2D solver expects an (7, ny, nx) array with:","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"1: X - 2D meshgrid coordinates\n2: Y - 2D meshgrid coordinates \n3: P-wave velocities [m/s]\n4: S-wave velocities [m/s]\n5: Densities [kg/m^3]\n6: 2D Thomsen Parameter epsilon \n7: 2D Thomsen Parameter delta ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"For an isotropic medium, set 6 & 7 zero.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The following script shows how to create a simple 2D velocity model.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"\nusing JLD2\n\n# spatial extends\nx_start = 0\nx_end = 10000\n\ny_start = 0 \ny_end = 10000\n\ndx = 10 # cell size x-direction \ndy = 10 # cell size y-direction \n\nxcoords = x_start:dx:x_end # x-coordinates\nycoords = y_start:dy:y_end # y-coordinates\n\nnx = length(xcoords) # number of grid points x-direction\nny = length(ycoords) # number of grid points y-direction\n\ndim = (ny, nx) # model dimensions \n\n# 2D meshgrid\nX = repeat(xcoords', ny, 1)\nY = repeat(ycoords,  1, nx)\n\nvp = zeros(dim);   # P-wave velocity\nvs = zeros(dim);   # S-wave velocity\nrho = zeros(dim);  # Density\neps0 = zeros(dim); # 2D Thomson parameter epsilon\ndel0 = zeros(dim); # 2D Thomson parameter delta\n\n# fill arrays with values\nvp[:,:]  .= 5000;  \nvs[:,:]  .= 2500;\nrho[:,:] .= 2800;\n\n# thomson parameter for vti media (zero for isotropic medium)\neps0[:,:] .= 0.2\ndel0[:,:] .= -0.15\n\n# velocity model array\nveldim = (7, ny, nx)\nvelmod = zeros(veldim)\n# fill with elastic properties\nvelmod[1,:,:] .= X\nvelmod[2,:,:] .= Y\nvelmod[3,:,:] .= vp\nvelmod[4,:,:] .= vs\nvelmod[5,:,:] .= rho\nvelmod[6,:,:] .= eps0\nvelmod[7,:,:] .= del0\n\n# save the velocity model\npath = joinpath(@__DIR__,\"velmod.jld2\") # add your actual path here \njldsave(path; velmod)","category":"page"},{"location":"userguide/velmod/#3D","page":"Velocity Models","title":"3D","text":"","category":"section"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The 3D solver expects an (13, nx, ny, nz) array with:","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"1: X - 3D meshgrid coordinates \n2: Y - 3D meshgrid coordinates \n3: Z - 3D meshgrid coordinates \n4: P-wave velocities [m/s] \n5: S-wave velocities [m/s] \n6: Densities [kg/m^3] ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"Tsvankin Parameter ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"7: varepsilon_1 \n8: varepsilon_2 \n9: gamma_1 \n10: gamma_2 \n11: delta_1 \n12: delta_2\n13: delta_3 ","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"For an isotropic medium, set 7-13 to zero.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"For a VTI medium, the relationship between Tsvankin and Thomsen Parameters can be used:","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"Tsvankin Parameter <=> Thomsen Parameter\nvarepsilon_1 = varepsilon_2 <=> varepsilon\ngamma_1 = gamma_2 <=> gamma\ndelta_1 = delta_2, delta_3 = 0 <=> delta","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"The following script shows how to create a simple 3D velocity model.","category":"page"},{"location":"userguide/velmod/","page":"Velocity Models","title":"Velocity Models","text":"\nusing JLD2\n\n# spatial extends\nx_start = 0\nx_end = 500\n\ny_start = 0 \ny_end = 500\n\nz_start = 0\nz_end = 500\n\ndx = 5 # cell size x-direction \ndy = 5 # cell size y-direction \ndz = 5 # cell size z-direction \n\nxcoords = x_start:dx:x_end # x-coordinates\nycoords = y_start:dy:y_end # y-coordinates\nzcoords = z_start:dz:z_end # z-coordinates\n\nnx = length(xcoords) # number of grid points x-direction\nny = length(ycoords) # number of grid points y-direction\nnz = length(zcoords) # number of grid points z-direction\n\n# 3D Meshgrid\nX = getindex.(Iterators.product(xcoords, ycoords, zcoords), 1)\nY = getindex.(Iterators.product(xcoords, ycoords, zcoords), 2)\nZ = getindex.(Iterators.product(xcoords, ycoords, zcoords), 3)\n\ndim = (nx, ny, nz) # model dimension\n\nvp = zeros(dim);    # P-wave velocity\nvs = zeros(dim);    # S-wave velocity\nrho = zeros(dim);   # Density velocity\neps1 = zeros(dim);  # Tsvankin parameter epsilon 1 \neps2 = zeros(dim);  # Tsvankin parameter epsilon 2\ngam1 = zeros(dim);  # Tsvankin parameter gamma 1 \ngam2 = zeros(dim);  # Tsvankin parameter gamma 2 \ndel1 = zeros(dim);  # Tsvankin parameter delta 1 \ndel2 = zeros(dim);  # Tsvankin parameter delta 2 \ndel3 = zeros(dim);  # Tsvankin parameter delta 3 \n\n# fill arrays with values\nvp[:,:,:] .= 5000;\nvs[:,:,:]  .= 2500;\nrho[:,:,:] .= 2800;\n\n# Tsvankin Parameter\neps1[:,:,:]  .= 0.05\neps2[:,:,:]  .= 0.1\ngam1[:,:,:]  .= 0.1\ngam2[:,:,:]  .= -0.05\ndel1[:,:,:]  .= 0.05\ndel2[:,:,:]  .= 0.025\ndel3[:,:,:]  .= -0.1\n\n# velocity model array\nveldim = (13, nx, ny, nz)\nvelmod = zeros(veldim);\n# fill with elastic properties\nvelmod[1,:,:,:] .= X\nvelmod[2,:,:,:] .= Y\nvelmod[3,:,:,:] .= Z\n\nvelmod[4,:,:,:] .= vp\nvelmod[5,:,:,:] .= vs\nvelmod[6,:,:,:] .= rho\n\nvelmod[7,:,:,:] .= eps1\nvelmod[8,:,:,:] .= eps2\nvelmod[9,:,:,:] .= gam1\nvelmod[10,:,:,:] .= gam2\nvelmod[11,:,:,:] .= del1\nvelmod[12,:,:,:] .= del2\nvelmod[13,:,:,:] .= del3\n\n# save velocity model in jld2 file\nusing JLD2\npath = joinpath(@__DIR__,\"velmod.jld2\") # add your actual path here \njldsave(path; velmod)","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#ElasticFDSG.dim2.config_template-Tuple{String}","page":"API Reference","title":"ElasticFDSG.dim2.config_template","text":"ElasticFDSG.config_template(path, dim)\n\nCreates and saves an empty template configuration.yaml file for a ElasticFDSG simulation.  Users can fill the template afterwards. \n\nArguments\n\npath::String: Path where the template is saved.\ndim::Real: dim = 2 => 2D-template, dim=3 => 3D-template\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim2.load_results-Tuple{String}","page":"API Reference","title":"ElasticFDSG.dim2.load_results","text":"ElasticFDSG.load_results(filename) Loads a result.h5 file into a dictionary.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim2.print_h5_tree-Tuple{String}","page":"API Reference","title":"ElasticFDSG.dim2.print_h5_tree","text":"ElasticFDSG.printh5tree(filename) Prints tree structure of a result.h5 file.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim2.runsim-Tuple{String, String}","page":"API Reference","title":"ElasticFDSG.dim2.runsim","text":"ElasticFDSG.dim2.runsim(CONFIGPATH, VELMODPATH) Run the 2D elastic forward simulation using the specified configuration and velocity model.\n\nArguments:\n\nCONFIGPATH::String: Path to the configuration.yaml file containing simulation settings.\nVELMODPATH::String: Path to the velocity model file. Supported formats: .jld2, .npy, and .npz.\n\nOptional Keyword Arguments:\n\nblock_size::Tuple=(32,32) : Specify numbers of threads launched on GPU. For CPU it will have no effect.\nreturn_::Bool=false: False -> Results will be saved as .h5 file as specified in the config file.                         True  -> Function returns FDSG2D struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim3.config_template-Tuple{String}","page":"API Reference","title":"ElasticFDSG.dim3.config_template","text":"ElasticFDSG.config_template(path, dim)\n\nCreates and saves an empty template configuration.yaml file for a ElasticFDSG simulation.  Users can fill the template afterwards. \n\nArguments\n\npath::String: Path where the template is saved.\ndim::Real: dim = 2 => 2D-template, dim=3 => 3D-template\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim3.load_results-Tuple{String}","page":"API Reference","title":"ElasticFDSG.dim3.load_results","text":"ElasticFDSG.load_results(filename) Loads a result.h5 file into a dictionary.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim3.print_h5_tree-Tuple{String}","page":"API Reference","title":"ElasticFDSG.dim3.print_h5_tree","text":"ElasticFDSG.printh5tree(filename) Prints tree structure of a result.h5 file.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.dim3.runsim-Tuple{String, String}","page":"API Reference","title":"ElasticFDSG.dim3.runsim","text":"ElasticFDSG.dim3.runsim(CONFIGPATH, VELMODPATH) Run the 3D elastic forward simulation using the specified configuration and velocity model.\n\nArguments:\n\nCONFIGPATH::String: Path to the configuration.yaml file containing simulation settings.\nVELMODPATH::String: Path to the velocity model file. Supported formats: .jld2, .npy, and .npz.\n\nOptional Keyword Arguments:\n\nblock_size::Tuple=(7,7,7) : Specify numbers of threads launched on GPU. For CPU it will have no effect.\nreturn_::Bool=false: False -> Results will be saved as .h5 file as specified in the config file.                         True  -> Function returns FDSG3D struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.config_template-Tuple{String}","page":"API Reference","title":"ElasticFDSG.config_template","text":"ElasticFDSG.config_template(path, dim)\n\nCreates and saves an empty template configuration.yaml file for a ElasticFDSG simulation.  Users can fill the template afterwards. \n\nArguments\n\npath::String: Path where the template is saved.\ndim::Real: dim = 2 => 2D-template, dim=3 => 3D-template\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.load_results-Tuple{String}","page":"API Reference","title":"ElasticFDSG.load_results","text":"ElasticFDSG.load_results(filename) Loads a result.h5 file into a dictionary.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ElasticFDSG.print_h5_tree-Tuple{String}","page":"API Reference","title":"ElasticFDSG.print_h5_tree","text":"ElasticFDSG.printh5tree(filename) Prints tree structure of a result.h5 file.\n\nArguments\n\nfilename::Stringg: Path to the results.h5 file.\n\n\n\n\n\n","category":"method"},{"location":"#ElasticFDSG.jl","page":"Home","title":"ElasticFDSG.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ElasticFDSG.jl is a Julia package for solving the elastic wave equation in the velocityâ€“stress formulation using the finite-difference method on a staggered grid.","category":"page"},{"location":"","page":"Home","title":"Home","text":"But why another implementation? In many existing tools, installing dependencies, configuring simulation setups, defining model parameters, and accessing results can be already complicated tasks â€” particularly for inexperienced users who are looking for a quick and straightforward workflow. ElasticFDSG was developed to offer a user-friendly experience while also maintaining flexibility to be applied to a wide variety of simulation scenarios. Users can easily customize their simulations by creating velocity models and configuration files in a straightforward manner, that can be directly passed to the solvers.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"2D and 3D elastic forward modelling on regular grids.\nVendor neutral CPU and GPU kernel (CPU, CUDA, Metal, AMDGPU, oneAPI) using KernelAbstractions.jl.\nSpatial derivatives of order 1 to 10.\nSecond order time marching.\nElastic isotropic or vertical transversal isotrop (VTI) 2D models using 2D Thomson parameter.\nElastic isotropic, VTI or orthorhombic (ORT) 3D models using Tsvankin parameter.\nElastic properties defined on full integer grid points.\nSolver can handle fully heterogeneous media.\nAbsorbing boundaries using Convolutional-Perfectly-Matched-Layer.\nMoment tensor sources. \nSave geophone receiver (velocity point sensors). \nSave Distributed Acoustic Sensing (DAS) receiver, aligned with model coordinate axis (strain-profiles).\nSave snapshots at specified time steps.\nEasy-to-read source code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A step by step user guide can be found in the User Guide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic examples are included in the git-repository examples/ folder. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Demo)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(ElasticFDSG)","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find this package helpful for your research, please consider citing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ElasticFDSG,\n  author       = {William Tegtow},\n  title        = {ElasticFDSG.jl: Simulating elastic wave propagation in 2D and 3D anisotropic media.},\n  year         = {2025},\n  doi          = {https://doi.org/10.5281/zenodo.14872584}\n}\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is still in its early stages, and only limited testing has been done so far. Any bug report or suggestion is very welcomed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nOld scripts may need to be revised to be compatible with the latest version.With v1.0.2, the structure of the configuration.yaml files has slightly changed. \nWith v1.0.2, 2D velocity models must now be saved as (Nx,Nz) arrays instead from previously (Nz,Nx). ","category":"page"}]
}
